"""Unit tests for BenchmarkBase class.

Tests cover:
- Initialization and property accessors
- Save and load operations (JSON-LD)
- Validation
- Cache management
- Metadata updates
- Magic methods (__str__, __repr__, __len__, __contains__, __getitem__, __eq__)
- Progress calculation
"""

import json
from pathlib import Path

import pytest

from karenina.benchmark.core.base import BenchmarkBase


@pytest.mark.unit
class TestBenchmarkBaseInit:
    """Tests for BenchmarkBase initialization."""

    def test_init_with_name_only(self) -> None:
        """Test initialization with just name."""
        base = BenchmarkBase(name="test")

        assert base.name == "test"
        # Description gets default value from create_jsonld_benchmark
        assert base.description is not None
        assert base.version == "0.1.0"
        assert base.creator == "Karenina Benchmarking System"
        assert base.question_count == 0
        assert base.is_empty

    def test_init_with_all_parameters(self) -> None:
        """Test initialization with all parameters."""
        base = BenchmarkBase(
            name="test",
            description="Test benchmark",
            version="2.0.0",
            creator="Test Author",
        )

        assert base.name == "test"
        assert base.description == "Test benchmark"
        assert base.version == "2.0.0"
        assert base.creator == "Test Author"

    def test_init_creates_checkpoint(self) -> None:
        """Test that initialization creates proper checkpoint."""
        base = BenchmarkBase(name="test")

        checkpoint = base.jsonld_data
        assert checkpoint.name == "test"
        assert checkpoint.dataFeedElement == []

    def test_init_builds_empty_cache(self) -> None:
        """Test that initialization builds empty questions cache."""
        base = BenchmarkBase(name="test")

        assert base._questions_cache == {}


@pytest.mark.unit
class TestBenchmarkBaseProperties:
    """Tests for BenchmarkBase properties."""

    def test_name_property(self) -> None:
        """Test name property getter and setter."""
        base = BenchmarkBase(name="original")

        assert base.name == "original"

        base.name = "updated"
        assert base.name == "updated"

    def test_description_property(self) -> None:
        """Test description property getter and setter."""
        base = BenchmarkBase(name="test")

        # Description has a default value
        original_desc = base.description
        assert original_desc is not None

        base.description = "Test description"
        assert base.description == "Test description"

    def test_version_property(self) -> None:
        """Test version property getter and setter."""
        base = BenchmarkBase(name="test")

        assert base.version == "0.1.0"

        base.version = "1.5.0"
        assert base.version == "1.5.0"

    def test_creator_property(self) -> None:
        """Test creator property getter and setter."""
        base = BenchmarkBase(name="test")

        assert base.creator == "Karenina Benchmarking System"

        base.creator = "Custom Creator"
        assert base.creator == "Custom Creator"

    def test_id_property(self) -> None:
        """Test id property getter and setter."""
        base = BenchmarkBase(name="test")

        # ID is auto-generated by create_jsonld_benchmark
        assert base.id is not None
        assert base.id.startswith("urn:uuid:karenina-checkpoint-")

        base.id = "custom-id-123"
        assert base.id == "custom-id-123"

    def test_created_at_property(self) -> None:
        """Test created_at property getter and setter."""
        base = BenchmarkBase(name="test")

        # Created timestamp is set automatically
        assert base.created_at is not None
        assert len(base.created_at) > 0

        base.created_at = "2025-01-01T00:00:00"
        assert base.created_at == "2025-01-01T00:00:00"

    def test_modified_at_property(self) -> None:
        """Test modified_at property getter and setter."""
        base = BenchmarkBase(name="test")

        # Modified timestamp is set automatically
        assert base.modified_at is not None

        base.modified_at = "2025-01-01T12:00:00"
        assert base.modified_at == "2025-01-01T12:00:00"

    def test_question_count_property(self) -> None:
        """Test question_count property."""
        base = BenchmarkBase(name="test")

        assert base.question_count == 0
        assert base.is_empty

    def test_finished_count_property(self) -> None:
        """Test finished_count property."""
        base = BenchmarkBase(name="test")

        assert base.finished_count == 0

    def test_is_empty_property(self) -> None:
        """Test is_empty property."""
        base = BenchmarkBase(name="test")

        assert base.is_empty is True

    def test_is_complete_property(self) -> None:
        """Test is_complete property."""
        base = BenchmarkBase(name="test")

        # Empty benchmark is not complete
        assert base.is_complete is False

    def test_jsonld_data_property(self) -> None:
        """Test jsonld_data property returns checkpoint."""
        base = BenchmarkBase(name="test")

        checkpoint = base.jsonld_data
        assert checkpoint.name == "test"


@pytest.mark.unit
class TestBenchmarkBaseLoad:
    """Tests for BenchmarkBase.load class method."""

    def test_load_from_nonexistent_file_raises(self, tmp_path: Path) -> None:
        """Test loading from nonexistent file raises FileNotFoundError."""
        with pytest.raises(FileNotFoundError, match="not found"):
            BenchmarkBase.load(tmp_path / "nonexistent.jsonld")

    def test_load_from_invalid_json_raises(self, tmp_path: Path) -> None:
        """Test loading from invalid JSON raises error."""

        invalid_file = tmp_path / "invalid.jsonld"
        invalid_file.write_text("not valid json")

        # Invalid JSON raises JSONDecodeError wrapped in ValueError
        with pytest.raises(ValueError):
            BenchmarkBase.load(invalid_file)

    def test_load_from_valid_jsonld(self) -> None:
        """Test loading from valid JSON-LD file."""
        # Create a minimal valid JSON-LD file
        # Use actual checkpoint fixture to get proper format
        from pathlib import Path as LibPath

        fixture_path = LibPath(__file__).parent.parent.parent.parent / "fixtures" / "checkpoints" / "minimal.jsonld"
        if not fixture_path.exists():
            # Skip test if fixture doesn't exist
            pytest.skip("Checkpoint fixture not found")

        base = BenchmarkBase.load(fixture_path)

        assert "minimal" in base.name
        assert base.question_count == 1

    def test_load_with_questions(self) -> None:
        """Test loading benchmark with questions."""
        # Use the multi_question fixture which has 5 questions
        from pathlib import Path as LibPath

        fixture_path = (
            LibPath(__file__).parent.parent.parent.parent / "fixtures" / "checkpoints" / "multi_question.jsonld"
        )
        if not fixture_path.exists():
            # Skip test if fixture doesn't exist
            pytest.skip("Checkpoint fixture not found")

        base = BenchmarkBase.load(fixture_path)

        assert base.question_count == 5
        assert len(base._questions_cache) == 5


@pytest.mark.unit
class TestBenchmarkBaseSave:
    """Tests for BenchmarkBase.save method."""

    def test_save_creates_jsonld_file(self, tmp_path: Path) -> None:
        """Test saving creates JSON-LD file."""
        base = BenchmarkBase(name="test-save", description="Test")

        output_path = tmp_path / "output.jsonld"
        base.save(output_path)

        assert output_path.exists()

        with open(output_path, encoding="utf-8") as f:
            data = json.load(f)

        assert data["name"] == "test-save"
        assert data["description"] == "Test"

    def test_save_adds_jsonld_extension(self, tmp_path: Path) -> None:
        """Test that save adds .jsonld extension if missing."""
        base = BenchmarkBase(name="test")

        output_path = tmp_path / "output"  # No extension
        base.save(output_path)

        assert (tmp_path / "output.jsonld").exists()

    def test_save_preserves_json_extension(self, tmp_path: Path) -> None:
        """Test that .json extension is preserved."""
        base = BenchmarkBase(name="test")

        output_path = tmp_path / "output.json"
        base.save(output_path)

        assert (tmp_path / "output.json").exists()

    def test_save_updates_modified_timestamp(self, tmp_path: Path) -> None:
        """Test that save updates the dateModified timestamp."""
        base = BenchmarkBase(name="test")

        original_modified = base.modified_at

        output_path = tmp_path / "output.jsonld"
        base.save(output_path)

        # Modified timestamp should be updated
        assert base.modified_at >= original_modified

    def test_save_creates_valid_json_structure(self, tmp_path: Path) -> None:
        """Test that save creates valid JSON structure."""
        base = BenchmarkBase(
            name="test",
            description="Description",
            version="1.0.0",
            creator="Creator",
        )

        output_path = tmp_path / "output.jsonld"
        base.save(output_path)

        # Should be able to load back
        loaded = BenchmarkBase.load(output_path)

        assert loaded.name == "test"
        assert loaded.description == "Description"
        assert loaded.version == "1.0.0"
        assert loaded.creator == "Creator"


@pytest.mark.unit
class TestBenchmarkBaseValidate:
    """Tests for BenchmarkBase.validate method."""

    def test_validate_empty_benchmark(self) -> None:
        """Test validation of empty benchmark."""
        base = BenchmarkBase(name="test")

        is_valid, error = base.validate()

        assert is_valid
        # Error message contains "Valid benchmark" when validation passes
        assert "Valid benchmark" in error or error == ""

    def test_validate_returns_tuple(self) -> None:
        """Test that validate returns a tuple."""
        base = BenchmarkBase(name="test")

        result = base.validate()

        assert isinstance(result, tuple)
        assert len(result) == 2


@pytest.mark.unit
class TestBenchmarkBaseGetProgress:
    """Tests for BenchmarkBase.get_progress method."""

    def test_get_progress_empty_benchmark(self) -> None:
        """Test progress calculation for empty benchmark."""
        base = BenchmarkBase(name="test")

        progress = base.get_progress()

        assert progress == 0.0

    def test_get_progress_with_finished_questions(self) -> None:
        """Test progress calculation with finished questions."""
        # Use the with_results fixture which has a finished question
        from pathlib import Path as LibPath

        fixture_path = (
            LibPath(__file__).parent.parent.parent.parent / "fixtures" / "checkpoints" / "with_results.jsonld"
        )
        if not fixture_path.exists():
            pytest.skip("Checkpoint fixture not found")

        base = BenchmarkBase.load(fixture_path)

        # Get progress - should be at least some percentage
        progress = base.get_progress()
        assert 0 <= progress <= 100


@pytest.mark.unit
class TestBenchmarkBaseSetMetadata:
    """Tests for BenchmarkBase.set_metadata method."""

    def test_set_metadata_name(self) -> None:
        """Test setting name metadata."""
        base = BenchmarkBase(name="original")

        base.set_metadata(name="updated")

        assert base.name == "updated"

    def test_set_metadata_description(self) -> None:
        """Test setting description metadata."""
        base = BenchmarkBase(name="test")

        base.set_metadata(description="New description")

        assert base.description == "New description"

    def test_set_metadata_version(self) -> None:
        """Test setting version metadata."""
        base = BenchmarkBase(name="test")

        base.set_metadata(version="2.0.0")

        assert base.version == "2.0.0"

    def test_set_metadata_creator(self) -> None:
        """Test setting creator metadata."""
        base = BenchmarkBase(name="test")

        base.set_metadata(creator="New Creator")

        assert base.creator == "New Creator"

    def test_set_metadata_multiple_fields(self) -> None:
        """Test setting multiple metadata fields at once."""
        base = BenchmarkBase(name="test")

        base.set_metadata(
            name="updated",
            version="3.0.0",
            creator="Multi Creator",
        )

        assert base.name == "updated"
        assert base.version == "3.0.0"
        assert base.creator == "Multi Creator"

    def test_set_metadata_updates_timestamp(self) -> None:
        """Test that set_metadata updates timestamp."""
        base = BenchmarkBase(name="test")

        original_modified = base.modified_at

        base.set_metadata(name="updated")

        assert base.modified_at >= original_modified


@pytest.mark.unit
class TestBenchmarkBaseMagicMethods:
    """Tests for BenchmarkBase magic methods."""

    def test_str_magic_method(self) -> None:
        """Test __str__ method."""
        base = BenchmarkBase(name="test-benchmark")

        str_repr = str(base)

        assert "test-benchmark" in str_repr
        assert "questions" in str_repr
        assert "0%" in str_repr or "0.0%" in str_repr

    def test_repr_magic_method(self) -> None:
        """Test __repr__ method."""
        base = BenchmarkBase(name="test", version="1.0.0")

        repr_str = repr(base)

        assert "Benchmark" in repr_str
        assert "test" in repr_str
        assert "1.0.0" in repr_str

    def test_len_magic_method(self) -> None:
        """Test __len__ method."""
        base = BenchmarkBase(name="test")

        assert len(base) == 0

    def test_contains_magic_method(self) -> None:
        """Test __contains__ method."""
        base = BenchmarkBase(name="test")

        assert "q1" not in base

    def test_getitem_magic_method(self) -> None:
        """Test __getitem__ method."""
        base = BenchmarkBase(name="test")

        with pytest.raises(ValueError, match="not found"):
            _ = base["nonexistent"]

    def test_eq_with_non_benchmark(self) -> None:
        """Test __eq__ with non-BenchmarkBase object."""
        base = BenchmarkBase(name="test")

        assert base != "not a benchmark"
        assert base != 42
        assert base is not None

    def test_eq_with_same_benchmark(self) -> None:
        """Test __eq__ with identical benchmark."""
        base1 = BenchmarkBase(name="test", version="1.0.0")
        base2 = BenchmarkBase(name="test", version="1.0.0")

        assert base1 == base2

    def test_eq_with_different_names(self) -> None:
        """Test __eq__ with different names."""
        base1 = BenchmarkBase(name="test1")
        base2 = BenchmarkBase(name="test2")

        assert base1 != base2

    def test_eq_with_different_versions(self) -> None:
        """Test __eq__ with different versions."""
        base1 = BenchmarkBase(name="test", version="1.0.0")
        base2 = BenchmarkBase(name="test", version="2.0.0")

        assert base1 != base2


@pytest.mark.unit
class TestBenchmarkBasePrivateMethods:
    """Tests for BenchmarkBase private methods."""

    def test_rebuild_cache_empty(self) -> None:
        """Test _rebuild_cache with empty benchmark."""
        base = BenchmarkBase(name="test")

        base._rebuild_cache()

        assert base._questions_cache == {}

    def test_rebuild_cache_from_fixture(self) -> None:
        """Test _rebuild_cache populates from loaded checkpoint."""
        from pathlib import Path as LibPath

        fixture_path = LibPath(__file__).parent.parent.parent.parent / "fixtures" / "checkpoints" / "minimal.jsonld"
        if not fixture_path.exists():
            pytest.skip("Checkpoint fixture not found")

        base = BenchmarkBase.load(fixture_path)

        # Cache should be populated after load
        assert len(base._questions_cache) > 0


@pytest.mark.unit
class TestBenchmarkBaseUpdateQuestionProperty:
    """Tests for _update_question_property method."""

    def test_update_question_property_with_fixture(self) -> None:
        """Test _update_question_property using actual fixture."""
        from pathlib import Path as LibPath

        fixture_path = LibPath(__file__).parent.parent.parent.parent / "fixtures" / "checkpoints" / "minimal.jsonld"
        if not fixture_path.exists():
            pytest.skip("Checkpoint fixture not found")

        # Load, save to tmp, then load again to test modification
        base = BenchmarkBase.load(fixture_path)
        q_id = list(base._questions_cache.keys())[0]

        # Update a property
        base._update_question_property(q_id, "test_field", "test_value")

        # Verify the checkpoint was modified
        assert base.jsonld_data.dateModified is not None

    def test_update_question_property_nonexistent_question(self) -> None:
        """Test _update_question_property with nonexistent question does nothing."""
        base = BenchmarkBase(name="test")

        # Should not raise, just silently do nothing
        base._update_question_property("nonexistent", "field", "value")

        # Benchmark should be unchanged
        assert base.question_count == 0
